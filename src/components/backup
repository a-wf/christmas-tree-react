import React, { useRef, useMemo, useEffect, useState } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'
import * as THREE from 'three'

// Configuration
const CONFIG = {
  TREE_POINTS: 50000,
  GROUND_POINTS: 4000,
  STAR_POINTS: 1200,
  HEART_POINTS: 1000,
  SNOW2D_POINTS: 10,
  TREE_HEIGHT: 12.0,
  CAM_DIST: 25,
  CAM_HEIGHT: 6.0,
  PITCH: -0.25,
}

// Color themes
const COLOR_THEMES = {
  classic: {
    name: 'Pink & White',
    tree: { deep: [255, 60, 180], medium: [255, 100, 190], light: [255, 160, 200], white: true },
    ground: { r: [100, 150], g: [150, 200], b: 255 },
    heart: [255, 220, 50],
    stars: [215, 255],
  },
  traditional: {
    name: 'Christmas Green',
    tree: { deep: [0, 80, 0], medium: [34, 139, 34], light: [50, 150, 50], white: true },
    ground: { r: [34, 80], g: [80, 120], b: [34, 60] },
    heart: [255, 215, 0],
    stars: [200, 255],
  },
  red: {
    name: 'Vermillion Red',
    tree: { deep: [220, 20, 60], medium: [255, 47, 0], light: [255, 99, 71], white: false },
    ground: { r: [139, 200], g: [0, 50], b: [0, 30] },
    heart: [255, 215, 0],
    stars: [255, 200],
  },
  blue: {
    name: 'Ice Blue',
    tree: { deep: [0, 100, 255], medium: [50, 150, 255], light: [100, 200, 255], white: true },
    ground: { r: [0, 50], g: [50, 150], b: 255 },
    heart: [255, 255, 200],
    stars: [150, 255],
  },
  purple: {
    name: 'Purple Dream',
    tree: { deep: [138, 43, 226], medium: [147, 112, 219], light: [186, 85, 211], white: false },
    ground: { r: [75, 150], g: [0, 80], b: [130, 255] },
    heart: [255, 215, 0],
    stars: [180, 255],
  },
}

// Generate tree particles
function generateTreePoints(theme) {
  const points = []
  const loops = 9
  const spiralN = Math.floor(CONFIG.TREE_POINTS * 0.7)
  const colors = theme.tree

  // 70% spiral lights
  for (let i = 0; i < spiralN; i++) {
    const u = Math.random()
    const h = Math.pow(u, 1.6)
    const y = CONFIG.TREE_HEIGHT * h + 0.2

    let baseR = Math.pow(1 - h, 1.1) * 3.2
    const branchWave = Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2))
    const branchFactor = 1.0 + 0.65 * branchWave
    baseR *= branchFactor

    const t = u * loops * Math.PI * 2
    const angle = t + (Math.random() - 0.5) * 0.44
    const r = baseR * (0.85 + Math.random() * 0.23)

    const x = Math.cos(angle) * r
    const z = Math.sin(angle) * r

    let color
    const colorRand = Math.random()
    // Add tiny red dots for traditional theme
    if (colors.deep[0] === 0 && colors.deep[1] === 80 && colors.deep[2] === 0 && colorRand < 0.10) {
      // Small chance of red dots for traditional green theme only
      color = new THREE.Color(200/255, 20/255, 20/255)
    } else if (colorRand < 0.15) {
      // Deep color
      const [r, g, b] = colors.deep
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else if (colorRand < 0.3) {
      // Medium color
      const [r, g, b] = colors.medium
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else if (colorRand < 0.45) {
      // Light color
      const [r, g, b] = colors.light
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else {
      // White (increased probability)
      if (colors.white) {
        // For traditional theme, use deeper green instead of white
        if (colors.deep[0] === 0 && colors.deep[1] === 80 && colors.deep[2] === 0) {
          // Traditional green theme only - use much deeper green
          const brightness = Math.floor(Math.random() * 25 + 60)
          color = new THREE.Color(brightness * 0.15/255, brightness/255, brightness * 0.15/255)
        } else {
          // Other themes - use normal white
          const brightness = Math.floor(Math.random() * 50 + 205)
          color = new THREE.Color(brightness/255, brightness/255, brightness/255)
        }
      } else {
        const [r, g, b] = colors.light
        color = new THREE.Color((r + 30)/255, (g + 30)/255, (b + 30)/255)
      }
    }

    points.push({ position: [x, y, z], color })
  }

  // 30% fill
  const fillN = CONFIG.TREE_POINTS - spiralN
  for (let i = 0; i < fillN; i++) {
    const h = Math.pow(Math.random(), 1.9)
    const y = CONFIG.TREE_HEIGHT * h + 0.2 + (Math.random() - 0.5) * 0.16

    let baseR = Math.pow(1 - h, 1.1) * 4.3
    const branchWave = Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2))
    const branchFactor = 1.0 + 0.65 * branchWave
    baseR *= branchFactor

    const r = baseR * Math.sqrt(Math.random())
    const angle = Math.random() * Math.PI * 2

    const x = Math.cos(angle) * r + (Math.random() - 0.5) * 0.16
    const z = Math.sin(angle) * r + (Math.random() - 0.5) * 0.16

    let color
    const colorRand = Math.random()
    if (colorRand < 0.25) {
      const [r, g, b] = colors.deep
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else if (colorRand < 0.5) {
      const [r, g, b] = colors.medium
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else if (colorRand < 0.75) {
      const [r, g, b] = colors.light
      color = new THREE.Color(r/255, (g + Math.random() * 20)/255, (b + Math.random() * 20)/255)
    } else {
      if (colors.white) {
        // For traditional theme, use deeper green instead of white
        if (colors.deep[0] === 0 && colors.deep[1] === 80 && colors.deep[2] === 0) {
          // Traditional green theme only - use deeper green
          const brightness = Math.floor(Math.random() * 30 + 100)
          color = new THREE.Color(brightness * 0.2/255, brightness/255, brightness * 0.2/255)
        } else {
          // Other themes - use normal white
          const brightness = Math.floor(Math.random() * 50 + 205)
          color = new THREE.Color(brightness/255, brightness/255, brightness/255)
        }
      } else {
        const [r, g, b] = colors.light
        color = new THREE.Color((r + 40)/255, (g + 40)/255, (b + 40)/255)
      }
    }

    points.push({ position: [x, y, z], color })
  }

  return points
}

// Generate ground particles
function generateGroundPoints(theme) {
  const points = []
  const rings = [4.6, 6.0, 7.4, 8.8, 10.2, 11.4]
  const ground = theme.ground

  for (let i = 0; i < CONFIG.GROUND_POINTS; i++) {
    const ring = rings[Math.floor(Math.random() * rings.length)]
    const r = ring + (Math.random() - 0.5) * 0.6
    const theta = Math.random() * Math.PI * 2
    const x = Math.cos(theta) * r
    const z = Math.sin(theta) * r
    const y = -0.25

    const colorRand = Math.random()
    let color
    if (colorRand < 0.3) {
      const r = Math.floor(Math.random() * (ground.r[1] - ground.r[0]) + ground.r[0])
      const g = Math.floor(Math.random() * (ground.g[1] - ground.g[0]) + ground.g[0])
      const b = Array.isArray(ground.b) ? Math.floor(Math.random() * (ground.b[1] - ground.b[0]) + ground.b[0]) : ground.b
      color = new THREE.Color(r/255, g/255, b/255)
    } else if (colorRand < 0.6) {
      const r = Math.floor(Math.random() * 30 + ground.r[0])
      const g = Math.floor(Math.random() * 40 + ground.g[0])
      const b = Array.isArray(ground.b) ? ground.b[1] : ground.b
      color = new THREE.Color(r/255, g/255, b/255)
    } else {
      const r = Math.floor(Math.random() * 30 + Math.min(150, ground.r[1]))
      const g = Math.floor(Math.random() * 30 + Math.min(200, ground.g[1]))
      const b = Array.isArray(ground.b) ? ground.b[1] : ground.b
      color = new THREE.Color(r/255, g/255, b/255)
    }

    points.push({ position: [x, y, z], color })
  }

  return points
}

// Generate star points
function generateStarPoints(theme) {
  const points = []
  const [min, max] = theme.stars

  for (let i = 0; i < CONFIG.STAR_POINTS; i++) {
    const x = (Math.random() - 0.5) * 36
    const z = (Math.random() - 0.5) * 36
    const y = 3 + Math.random() * 15
    const base = Math.floor(Math.random() * (max - min) + min)
    const color = new THREE.Color(base/255, base/255, 255/255)

    points.push({ position: [x, y, z], color })
  }

  return points
}

// Generate star mesh (actual 3D star geometry, not particles)
function StarMesh({ theme }) {
  const starRef = useRef()
  const [r, g, b] = theme.heart
  
  const starGeometry = useMemo(() => {
    const shape = new THREE.Shape()
    const outerRadius = 0.55
    const innerRadius = 0.22
    const numPoints = 5
    
    for (let i = 0; i < numPoints * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius
      const angle = (i * Math.PI) / numPoints - Math.PI / 2
      const x = Math.cos(angle) * radius
      const y = Math.sin(angle) * radius
      if (i === 0) shape.moveTo(x, y)
      else shape.lineTo(x, y)
    }
    shape.closePath()
    
    const extrudeSettings = {
      depth: 0.22,
      bevelEnabled: true,
      bevelThickness: 0.07,
      bevelSize: 0.07,
      bevelSegments: 4
    }
    
    return new THREE.ExtrudeGeometry(shape, extrudeSettings)
  }, [])
  
  const starColor = useMemo(() => new THREE.Color(r/255, g/255, b/255), [r, g, b])
  const emissiveColor = useMemo(() => new THREE.Color(
    Math.max(0, r - 50)/255, 
    Math.max(0, g - 50)/255, 
    Math.max(0, b - 50)/255
  ), [r, g, b])
  
  // Gentle rotation animation
  useFrame((state) => {
    if (starRef.current) {
      starRef.current.rotation.z += 0.005
    }
  })
  
  return (
    <group position={[0, CONFIG.TREE_HEIGHT + 0.4, 0]}>
      <mesh ref={starRef} geometry={starGeometry} rotation={[0, 0, Math.PI]}>
        <meshStandardMaterial
          color={starColor}
          emissive={emissiveColor}
          emissiveIntensity={1.8}
          metalness={0.8}
          roughness={0.15}
        />
      </mesh>
      
      {/* Outer glow star */}
      <mesh geometry={starGeometry} rotation={[0, 0, Math.PI]} position={[0, 0, -0.12]} scale={1.08}>
        <meshBasicMaterial
          color={0xffff00}
          transparent={true}
          opacity={0.2}
        />
      </mesh>
      
      {/* Point light at star */}
      <pointLight
        position={[0, 0, 0.3]}
        color={starColor}
        intensity={2.5}
        distance={12}
      />
    </group>
  )
}

// Generate heart points - REMOVED, replaced by StarMesh
function generateHeartPoints(theme) {
  return [] // No longer using particle-based star
}

// Particle system component
function Particles({ points }) {
  const meshRef = useRef()

  const [positions, colors] = useMemo(() => {
    const positions = new Float32Array(points.length * 3)
    const colors = new Float32Array(points.length * 3)

    points.forEach((p, i) => {
      positions[i * 3] = p.position[0]
      positions[i * 3 + 1] = p.position[1]
      positions[i * 3 + 2] = p.position[2]

      colors[i * 3] = p.color.r
      colors[i * 3 + 1] = p.color.g
      colors[i * 3 + 2] = p.color.b
    })

    return [positions, colors]
  }, [points])

  return (
    <points ref={meshRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={positions.length / 3}
          args={[positions, 3]}
        />
        <bufferAttribute
          attach="attributes-color"
          count={colors.length / 3}
          args={[colors, 3]}
        />
      </bufferGeometry>
      <pointsMaterial size={0.2} vertexColors={true} sizeAttenuation={true} transparent={true} opacity={0.95} />
    </points>
  )
}

// Snowflakes component (2D overlay, no Three.js hooks)
function Snowflakes() {
  const [flakes, setFlakes] = useState(() => {
    return Array.from({ length: CONFIG.SNOW2D_POINTS }, () => ({
      x: Math.random() * (typeof window !== 'undefined' ? window.innerWidth : 1600),
      y: -80 - Math.random() * 70,
      radius: 10 + Math.random() * 6,
      speed: 30 + Math.random() * 15,
    }))
  })

  useEffect(() => {
    let animationId
    let lastTime = Date.now()

    const animate = () => {
      const now = Date.now()
      const delta = (now - lastTime) / 1000
      lastTime = now

      setFlakes((prev) =>
        prev.map((flake) => {
          let newY = flake.y + flake.speed * delta
          let newX = flake.x

          if (newY > window.innerHeight + 50) {
            newY = -80 - Math.random() * 70
            newX = Math.random() * window.innerWidth
          }

          return { ...flake, x: newX, y: newY }
        })
      )

      animationId = requestAnimationFrame(animate)
    }

    animationId = requestAnimationFrame(animate)
    return () => cancelAnimationFrame(animationId)
  }, [])

  return (
    <div
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 100,
      }}
    >
      {flakes.map((flake, i) => (
        <div
          key={i}
          style={{
            position: 'absolute',
            left: flake.x,
            top: flake.y,
            width: flake.radius * 2,
            height: flake.radius * 2,
            borderRadius: '50%',
            background: 'radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.3) 50%, transparent 70%)',
            boxShadow: '0 0 10px rgba(255,255,255,0.5)',
          }}
        />
      ))}
    </div>
  )
}

// Scene setup
function Scene({ currentTheme }) {
  const groupRef = useRef()
  const { camera } = useThree()
  const [seed, setSeed] = useState(0)

  const theme = COLOR_THEMES[currentTheme]
  const treePoints = useMemo(() => generateTreePoints(theme), [seed, currentTheme])
  const groundPoints = useMemo(() => generateGroundPoints(theme), [seed, currentTheme])
  const starPoints = useMemo(() => generateStarPoints(theme), [seed, currentTheme])

  useEffect(() => {
    camera.position.set(0, CONFIG.CAM_HEIGHT + 4, CONFIG.CAM_DIST+5)
    camera.rotation.x = CONFIG.PITCH
  }, [camera])

  useFrame((state) => {
    if (groupRef.current) {
      groupRef.current.rotation.y += 0.002
    }
  })

  return (
    <group ref={groupRef} position={[0, -3, 0]}>
      <Particles points={treePoints} />
      <Particles points={groundPoints} />
      <Particles points={starPoints} />
      <StarMesh theme={theme} />
      
      <ambientLight intensity={0.8} />
      <pointLight position={[10, 10, 10]} intensity={1.5} />
      <pointLight position={[-10, 5, -10]} color="#6688ff" intensity={0.8} />
    </group>
  )
}

// Main component
export default function ChristmasTree() {
  const [currentTheme, setCurrentTheme] = useState(() => {
    const saved = localStorage.getItem('christmasTheme')
    return (saved && COLOR_THEMES[saved]) ? saved : 'classic'
  })
  const [userName, setUserName] = useState(() => {
    return localStorage.getItem('christmasName') || ''
  })

  const cycleTheme = () => {
    const themes = Object.keys(COLOR_THEMES)
    const currentIndex = themes.indexOf(currentTheme)
    const nextIndex = (currentIndex + 1) % themes.length
    const nextTheme = themes[nextIndex]
    setCurrentTheme(nextTheme)
    localStorage.setItem('christmasTheme', nextTheme)
  }

  const handleNameChange = (e) => {
    const name = e.target.value
    setUserName(name)
    if (name.trim()) {
      localStorage.setItem('christmasName', name.trim())
    } else {
      localStorage.removeItem('christmasName')
    }
  }

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen()
    } else {
      document.exitFullscreen()
    }
  }

  const displayName = userName.trim() || '[Name]'
  const themeName = COLOR_THEMES[currentTheme].name

  return (
    <>
      <Canvas
        camera={{ position: [0, CONFIG.CAM_HEIGHT, CONFIG.CAM_DIST], fov: 45 }}
        style={{ background: '#000' }}
      >
        <Scene currentTheme={currentTheme} />
        <OrbitControls
          enablePan={true}
          enableZoom={true}
          enableRotate={true}
          minDistance={10}
          maxDistance={50}
        />
      </Canvas>

      <div className="ui-overlay">
        <h1 className="title">Merry Christmas {displayName}</h1>
        
        <div className="top-right-controls">
          <button className="elegant-btn" onClick={toggleFullscreen}>
            â›¶ Fullscreen
          </button>
        </div>

        <div className="controls-container">
          <input
            type="text"
            className="name-input"
            placeholder="Enter Name"
            value={userName}
            onChange={handleNameChange}
          />
          
          <button className="elegant-btn" onClick={cycleTheme}>
            ðŸŽ¨ {themeName}
          </button>
          
          <div className="hint-text">Press 'H' to hide UI</div>
        </div>
      </div>

      <Snowflakes />
    </>
  )
}
